---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  error=FALSE, warning=FALSE, message=FALSE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# betaregscale

<!-- badges: start -->
[![pkgdown](https://github.com/evandeilton/betaregscale/actions/workflows/pkgdown.yaml/badge.svg)](https://github.com/evandeilton/betaregscale/actions/workflows/pkgdown.yaml)
<!-- badges: end -->

O pacote betaregscale fornece funções em R destinadas ao ajuste de modelos de regressão beta. É ideal para dados derivados de escalas que se encaixam na distribuição beta, como Escalas de Dor, Likert, entre outras. A característica distintiva deste pacote é a capacidade de avaliar a incerteza do instrumento de forma intervalar. O framework suporta modelos com dispersão fixa ou variável, operando sob o paradigma de máxima verossimilhança. Além disso, o pacote inclui funções para simulações, avaliação de desempenho dos modelos e ajustes a dados reais. O código-fonte e contribuições estão disponíveis no repositório oficial do GitHub. Detalhes sobre instalação e uso podem ser encontrados na documentação do pacote.

betaregscale é direcionado à modelagem de dados cuja variável resposta se enquadra em um intervalo contínuo, como $y = (y_s;y_i)$. Ele é versátil, lidando com censura à esquerda, direita ou intervalar independentemente do tempo. Suas aplicações incluem pesquisas de opinião, avaliações de produtos, escalas de dor (NRS-11, NRS-21, NRS-101), análises de compostos químicos, entre outros. Utilizando a distribuição beta, ele modela os dados em uma estrutura de regressão, relacionando variáveis explicativas à variável resposta intervalar. Também permite preditores lineares para coeficientes associados à média e dispersão, resultando em estimativas robustas e precisas dos parâmetros do modelo.

## Principais funcionalidades

O pacote `betaregscale` apresenta:

+ Modelagem de regressão beta com dispersões fixa e variável.
+ Simulação de dados para avaliar desempenho dos modelos em diversos cenários.
+ Métricas de adequação do ajuste, como AIC e BIC, acessíveis via `gof()`.
+ Funções padrão como `coef`, `vcov`, `fitted`, `residuals`, `summary`, e `print` implementadas para a classe `betaregscale`, facilitando análises.
+ Recursos para ajustar e comparar modelos com diversas combinações de variáveis explicativas para $\mu$ e $\phi$.

> Para uma exploração aprofundada de cada função e exemplos práticos, consulte a documentação disponível neste site.


## Instalação

Você pode instalar o pacote com esse comando abaixo.

```{r, eval=FALSE}
if(!require(betaregscale)){
  devtools::install_github("evandeilton/betaregscale")  
}
require(betaregscale, quietly = TRUE)
```

```{r, eval=TRUE, echo=FALSE}
require(betaregscale, quietly = TRUE)
```


## Exemplos de Uso

A seguir, apresentamos exemplos práticos para demonstrar a aplicabilidade das funções do pacote.

### Simulação de Dados para Modelo Beta Intervalar com Dispersão Fixa

A função `betaregscale_simula_dados` permite gerar amostras de variáveis beta com dispersão fixa, considerando diferentes funções de ligação.

No código R abaixo, exemplificamos sua aplicação:

+ Primeiro, geramos um conjunto de 100 observações com duas variáveis independentes (x1 e x2) a partir de uma distribuição normal.
+ Em seguida, usamos `betaregscale_simula_dados` para simular dados, definindo parâmetros específicos.

> Nota: O parâmetro `type` determina o tratamento do intervalo. Quando `type` é 'm', centraliza-se `y` ao meio. Por exemplo, se registramos o valor $y = 6$, este se transforma em $y_t = 6/10 = 0.6$. Assim, para considerar a incerteza da medida, pode-se sugerir que o valor observado esteja no intervalo $y_{left} = 5.5$ e $y_{right} = 6.6$.


```{r}
# Criar um conjunto de dados de exemplo
set.seed(4255)
n <- 200
dados <- data.frame(x1 = rnorm(n),
                    x2 = rnorm(n))

dados_simulados <- betaregscale_simula_dados(
  formula = ~ x1 + x2,
  dados = dados,
  betas = c(0.3, -0.6, 0.4),
  phi = 1/10,
  link = "logit",
  link_phi = "logit",
  ncuts = 100,
  type = "m",
  repar = "2"
)
dados_simulados %>%
  head() %>%
  knitr::kable(digits = 4, caption = "")
```

### Ajuste de modelos com dispersão fixa

+ Exemplo do ajuste com optim direto para uma lista de links

```{r}
links <- c("logit","probit","cauchit","cloglog")
names(links) <- links

fit_fixo <- purrr::map(links, .f = function(link){
  betaregscale(
    formula = y ~ x1 + x2,
    dados = dados_simulados,
    link = link,
    link_phi = "logit",
    repar = "2",
    num_hessiana = TRUE)
})
```

+ Resumo das estimativas e bondade

- Estimativas do ajuste e Bondade
```{r, results='asis'}
resumo <- purrr::map(fit_fixo, function(fit){
  summary(fit)
})
```


```{r}
purrr::map_df(resumo, function(res){
  res$est
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")  
```
```{r}
purrr::map_df(resumo, function(res){
  res$gof
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")
```

+ Exemplo do ajuste com `bbmle` direto para uma lista de links

```{r}
require(bbmle, quietly = TRUE)
links <- c("logit","probit","cauchit","cloglog")
names(links) <- links

fit_fixo_bbmle <- purrr::map(links, .f = function(link){
  betaregscale_bbmle(
    formula = y ~ x1 + x2,
    dados = dados_simulados,
    link = link,
    link_phi = "logit",
    repar = "2",
    num_hessiana = TRUE)
})
```

- Gráficos dos perfis de verossimilhança

```{r, results='asis'}
fit_fixo_profiles <- purrr::map(fit_fixo_bbmle, profile)
purrr::walk(names(fit_fixo_profiles), function(p){
  cat("\n+", p, "\n")
  plot(fit_fixo_profiles[[p]])
})
```

### Simulação de Dados para Modelo Beta Intervalar com Dispersão Variável

Neste exemplo em R, geramos dados simulados para um modelo beta com dispersão variável utilizando a função `betaregscale_simula_dados_z`. O fluxo é descrito a seguir:

+ Estabelecer uma semente e determinar o tamanho da amostra, bem como as fórmulas para as variáveis explicativas x e z.
  
+ Construir um conjunto de dados com 50 observações contendo quatro variáveis independentes (x1, x2, z1 e z2). Estas são oriundas de distribuições normal e uniforme.

+ Empregar `betaregscale_simula_dados_z` para simular os dados, definindo os parâmetros desejados, incluindo fórmulas, coeficientes de regressão, funções de ligação e número de pontos de corte.


```{r}
# Criar um conjunto de dados de exemplo
set.seed(2222)
n <- 200
fx <- ~ x1 + x2 + x3
fz <- ~ z1 + z2

dados <- data.frame(
  x1 = rnorm(n),
  x2 = rnorm(n),
  x3 = rbinom(n, size = 1, prob = 1/2),
  z1 = rnorm(n),
  z2 = rnorm(n)
)

dados_simulados <- betaregscale_simula_dados_z(
  formula_x = fx,
  formula_z = fz,
  dados = dados,
  betas = c(0.2, -0.6, 0.2, 0.2),
  zetas = c(0.2, -0.8, 0.6),
  link = "logit",
  link_phi = "logit",
  ncuts = 100,
  type = "m",
  repar = "2"
)

dados_simulados %>% 
  head() %>%
  knitr::kable(digits = 4, caption = "")
```

### Ajuste de modelos com dispersão variável

+ Exemplo do ajuste com optim direto para uma lista de links

```{r}
links <- c("logit","probit","cauchit","cloglog")
names(links) <- links

fit_variavel <- purrr::map(links, .f = function(link){
  betaregscale(
    formula = y ~x1 + x2 | z1,
    dados = dados_simulados,
    link = link,
    link_phi = "logit",
    repar = "2",
    num_hessiana = TRUE)
})
```

+ Resumo das estimativas e bondade

- Estimativas do ajuste e Bondade
```{r, results='asis'}
resumo <- purrr::map(fit_variavel, function(fit){
  summary(fit)
})
```


```{r}
purrr::map_df(resumo, function(res){
  res$est
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")  
```

```{r}
purrr::map_df(resumo, function(res){
  res$gof
  }, .id = "link") %>% 
  knitr::kable(digits = 4, caption = "")
```

+ Exemplo do ajuste com `bbmle` direto para uma lista de links

```{r}
require(bbmle, quietly = TRUE)
links <- c("logit","probit","cloglog")
names(links) <- links

fit_variavel_bbmle <- purrr::map(links, .f = function(link){
  betaregscale_bbmle(
    formula = y ~ x1 + x2 | z1,
    dados = dados_simulados,
    link = link,
    link_phi = "logit",
    lim = 0.5,
    repar = "2",
    num_hessiana = FALSE)
})
```

- Gráficos dos perfis de verossimilhança

```{r, results='asis'}
fit_variavel_profiles <- purrr::map(fit_variavel_bbmle, function(m){
  out <- try(profile(m))
  if(!inherits(out, "try-error")){
    return(out)
  }
})
purrr::walk(names(fit_variavel_profiles), function(p){
  cat("\n+", p, "\n")
  plot(fit_variavel_profiles[[p]])
})
```

### Outras funções genéricas

```{r, eval=FALSE}
## Resumo das estimativas e bondades
summary(fit_fixo$logit)

## Coeficientes do modelo
coef(fit_fixo$logit)

## Matriz de covariâncias
vcov(fit_fixo$logit)

## Resíduo dos valores preditos em relação ao ponto médio do intervalo de y, 
## isto é (left + right) / 2
resid(fit_fixo$logit)

## Valores preditos
fitted(fit_fixo$logit)

## Print do modelo
print(fit_fixo$logit)
```

----

## Work in progress ...

![](https://media4.giphy.com/media/LHZyixOnHwDDy/giphy.gif)




