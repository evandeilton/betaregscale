% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/prepare.R
\name{bs_prepare}
\alias{bs_prepare}
\title{Pre-process analyst data for beta interval regression}
\usage{
bs_prepare(
  data,
  y = "y",
  delta = "delta",
  left = "left",
  right = "right",
  ncuts = 100L,
  type = "m",
  lim = 0.5
)
}
\arguments{
\item{data}{A \code{data.frame} containing the response and
(optionally) covariates.}

\item{y}{Character: name of the score column (default \code{"y"}).}

\item{delta}{Character: name of the censoring indicator column
(default \code{"delta"}). Values must be in \code{{0, 1, 2, 3}}.}

\item{left}{Character: name of the left-endpoint column
(default \code{"left"}).}

\item{right}{Character: name of the right-endpoint column
(default \code{"right"}).}

\item{ncuts}{Integer: number of scale categories (default 100).}

\item{type}{\strong{Deprecated.}
Character: interval type for interior scores when only
\code{y} and \code{delta} are available.
\code{"m"} = midpoint (default), \code{"l"} = left-aligned,
\code{"r"} = right-aligned.
This argument will be removed in a future version.}

\item{lim}{Numeric: half-width of the uncertainty region
(default 0.5). Used only when constructing intervals from \code{y}
alone.}
}
\value{
A \code{data.frame} with the following columns appended or
  replaced:
  \describe{
    \item{\code{left}}{Lower endpoint on \eqn{(0, 1)}.}
    \item{\code{right}}{Upper endpoint on \eqn{(0, 1)}.}
    \item{\code{yt}}{Midpoint approximation on \eqn{(0, 1)}.}
    \item{\code{y}}{Original scale value (preserved for reference).}
    \item{\code{delta}}{Censoring indicator: 0 = exact, 1 = left,
      2 = right, 3 = interval.}
  }
  Covariate columns are preserved.
  The output carries attributes \code{"bs_prepared"} (\code{TRUE}),
  \code{"ncuts"}, \code{"type"}, and \code{"lim"} so that
  \code{\link{betaregscale}} can detect prepared data and skip the
  internal \code{\link{check_response}} call.
}
\description{
Validates and transforms raw data into the format required by
\code{\link{betaregscale}}.
The analyst can supply data in several ways:

\enumerate{
  \item \strong{Minimal}: only the score \code{y}. Censoring is
    inferred automatically (equivalent to \code{\link{check_response}}).
  \item \strong{Classic}: \code{y} + explicit \code{delta}. The
    analyst states the censoring type; interval endpoints are computed.
  \item \strong{Interval}: \code{left} and/or \code{right} columns
    (on the original scale). Censoring is inferred from the NA pattern.
  \item \strong{Full}: \code{y}, \code{left}, and \code{right}
    together. The analyst's own endpoints are rescaled directly to
    \eqn{(0, 1)}.
}

All covariate columns are preserved unchanged in the output data frame.
}
\details{
\strong{Priority rule}: if \code{delta} is provided (non-\code{NA}),
it takes precedence.
When \code{delta} is \code{NA}, the function infers the censoring type
from the pattern of \code{left}, \code{right}, and \code{y}:

\tabular{llllll}{
  \code{left} \tab \code{right} \tab \code{y} \tab \code{delta}
  \tab Interpretation \tab Inferred \eqn{\delta} \cr
  \code{NA}   \tab  5  \tab \code{NA} \tab \code{NA}
  \tab Left-censored (below 5) \tab 1 \cr
  20          \tab \code{NA} \tab \code{NA} \tab \code{NA}
  \tab Right-censored (above 20) \tab 2 \cr
  30          \tab 45  \tab \code{NA} \tab \code{NA}
  \tab Interval-censored [30, 45] \tab 3 \cr
  \code{NA}   \tab \code{NA} \tab 50 \tab \code{NA}
  \tab Exact observation \tab 0 \cr
  \code{NA}   \tab \code{NA} \tab 50 \tab 3
  \tab Analyst says interval \tab 3 \cr
  \code{NA}   \tab \code{NA} \tab 0  \tab 1
  \tab Analyst says left-censored \tab 1 \cr
  \code{NA}   \tab \code{NA} \tab 99 \tab 2
  \tab Analyst says right-censored \tab 2 \cr
}

When \code{y}, \code{left}, and \code{right} are all present for the
same observation, the analyst's \code{left}/\code{right} values are
used directly (rescaled by \eqn{K =} \code{ncuts}) and \code{delta}
is set to 3 (interval-censored) unless the analyst supplied
\code{delta} explicitly.

All endpoints are clamped to \eqn{[\epsilon, 1 - \epsilon]} with
\eqn{\epsilon = 10^{-5}}.
}
\examples{
# --- Mode 1: y only (automatic classification, like check_response) ---
d1 <- data.frame(y = c(0, 3, 5, 7, 10), x1 = rnorm(5))
bs_prepare(d1, ncuts = 10)

# --- Mode 2: y + explicit delta ---
d2 <- data.frame(
  y     = c(50, 0, 99, 50),
  delta = c(0, 1, 2, 3),
  x1    = rnorm(4)
)
bs_prepare(d2, ncuts = 100)

# --- Mode 3: left/right with NA patterns ---
d3 <- data.frame(
  left  = c(NA, 20, 30, NA),
  right = c(5, NA, 45, NA),
  y     = c(NA, NA, NA, 50),
  x1    = rnorm(4)
)
bs_prepare(d3, ncuts = 100)

# --- Mode 4: y + left + right (analyst-supplied intervals) ---
d4 <- data.frame(
  y     = c(50, 75),
  left  = c(48, 73),
  right = c(52, 77),
  x1    = rnorm(2)
)
bs_prepare(d4, ncuts = 100)

# --- End-to-end workflow ---
\donttest{
set.seed(42)
n <- 200
dat <- data.frame(x1 = rnorm(n), x2 = rnorm(n))
sim <- betaregscale_simulate(
  formula = ~ x1 + x2, data = dat,
  beta = c(0.2, -0.5, 0.3), phi = 1 / 5
)
prep <- bs_prepare(sim, ncuts = 100)
fit <- betaregscale(y ~ x1 + x2, data = prep)
summary(fit)
}

}
\seealso{
\code{\link{check_response}} for the automatic
  classification of raw scale scores;
  \code{\link{betaregscale}} for fitting the model.
}
